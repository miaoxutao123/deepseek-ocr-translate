import os
import logging
from typing import List, Dict, Any
from pathlib import Path
from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib import colors
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.lib.enums import TA_LEFT, TA_RIGHT

logger = logging.getLogger(__name__)


class ExportService:
    """Service for exporting translations to various formats"""

    @staticmethod
    def export_to_markdown(
        sentences: List[Dict[str, str]],
        source_language: str = "Source",
        target_language: str = "Translation"
    ) -> str:
        """
        Export to Markdown format

        Args:
            sentences: List of sentence pairs
            source_language: Source language name
            target_language: Target language name

        Returns:
            Markdown formatted string
        """
        lines = [
            f"# Translation: {source_language} → {target_language}\n",
            f"Generated by OCR and Translate System\n",
            "---\n\n"
        ]

        for idx, pair in enumerate(sentences, 1):
            lines.append(f"## {idx}\n\n")
            lines.append(f"**{source_language}:**\n\n")
            lines.append(f"{pair['source']}\n\n")
            lines.append(f"**{target_language}:**\n\n")
            lines.append(f"{pair['translation']}\n\n")
            lines.append("---\n\n")

        return "".join(lines)

    @staticmethod
    def export_to_txt(
        sentences: List[Dict[str, str]],
        format_type: str = "parallel"
    ) -> str:
        """
        Export to plain text

        Args:
            sentences: List of sentence pairs
            format_type: 'parallel' or 'sequential'

        Returns:
            Plain text string
        """
        if format_type == "parallel":
            # Side-by-side format
            lines = []
            max_width = 50

            for pair in sentences:
                source = pair['source']
                translation = pair['translation']

                # Wrap long lines
                source_lines = [source[i:i+max_width] for i in range(0, len(source), max_width)]
                trans_lines = [translation[i:i+max_width] for i in range(0, len(translation), max_width)]

                max_lines = max(len(source_lines), len(trans_lines))

                for i in range(max_lines):
                    src = source_lines[i] if i < len(source_lines) else ""
                    trn = trans_lines[i] if i < len(trans_lines) else ""
                    lines.append(f"{src:<50} | {trn}\n")

                lines.append("-" * 103 + "\n")

            return "".join(lines)

        else:
            # Sequential format
            lines = []
            for idx, pair in enumerate(sentences, 1):
                lines.append(f"[{idx}]\n")
                lines.append(f"Source: {pair['source']}\n")
                lines.append(f"Translation: {pair['translation']}\n")
                lines.append("\n")

            return "".join(lines)

    @staticmethod
    def export_to_docx(
        sentences: List[Dict[str, str]],
        output_path: str,
        source_language: str = "Source",
        target_language: str = "Translation"
    ):
        """
        Export to Word document

        Args:
            sentences: List of sentence pairs
            output_path: Path to save the document
            source_language: Source language name
            target_language: Target language name
        """
        doc = Document()

        # Add title
        title = doc.add_heading(f"Translation: {source_language} → {target_language}", 0)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # Add metadata
        doc.add_paragraph("Generated by OCR and Translate System").alignment = WD_ALIGN_PARAGRAPH.CENTER
        doc.add_paragraph()

        # Add each translation pair
        for idx, pair in enumerate(sentences, 1):
            # Add section number
            heading = doc.add_heading(f"Section {idx}", level=2)

            # Add source text
            source_para = doc.add_paragraph()
            source_run = source_para.add_run(f"{source_language}: ")
            source_run.bold = True
            source_para.add_run(pair['source'])

            # Add translation
            trans_para = doc.add_paragraph()
            trans_run = trans_para.add_run(f"{target_language}: ")
            trans_run.bold = True
            trans_run.font.color.rgb = RGBColor(0, 0, 255)
            trans_para.add_run(pair['translation'])

            # Add separator
            doc.add_paragraph()

        doc.save(output_path)
        logger.info(f"Exported to DOCX: {output_path}")

    @staticmethod
    def export_to_pdf(
        sentences: List[Dict[str, str]],
        output_path: str,
        source_language: str = "Source",
        target_language: str = "Translation"
    ):
        """
        Export to PDF document

        Args:
            sentences: List of sentence pairs
            output_path: Path to save the PDF
            source_language: Source language name
            target_language: Target language name
        """
        doc = SimpleDocTemplate(output_path, pagesize=A4)
        story = []

        styles = getSampleStyleSheet()

        # Create custom styles
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#333333'),
            spaceAfter=30,
            alignment=TA_LEFT
        )

        heading_style = ParagraphStyle(
            'CustomHeading',
            parent=styles['Heading2'],
            fontSize=14,
            textColor=colors.HexColor('#666666'),
            spaceAfter=10
        )

        # Add title
        title = Paragraph(f"Translation: {source_language} → {target_language}", title_style)
        story.append(title)
        story.append(Spacer(1, 12))

        # Add content
        for idx, pair in enumerate(sentences, 1):
            # Section heading
            section_heading = Paragraph(f"Section {idx}", heading_style)
            story.append(section_heading)

            # Create table for parallel display
            data = [
                [source_language, target_language],
                [pair['source'], pair['translation']]
            ]

            table = Table(data, colWidths=[250, 250])
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ]))

            story.append(table)
            story.append(Spacer(1, 20))

        doc.build(story)
        logger.info(f"Exported to PDF: {output_path}")

    @staticmethod
    def export_translation(
        sentences: List[Dict[str, str]],
        output_path: str,
        format_type: str = "markdown",
        source_language: str = "Source",
        target_language: str = "Translation"
    ) -> str:
        """
        Export translation to specified format

        Args:
            sentences: List of sentence pairs
            output_path: Path to save the file
            format_type: Output format (markdown, txt, docx, pdf)
            source_language: Source language name
            target_language: Target language name

        Returns:
            Path to the exported file
        """
        os.makedirs(os.path.dirname(output_path), exist_ok=True)

        if format_type == "markdown":
            content = ExportService.export_to_markdown(
                sentences, source_language, target_language
            )
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(content)

        elif format_type == "txt":
            content = ExportService.export_to_txt(sentences)
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(content)

        elif format_type == "docx":
            ExportService.export_to_docx(
                sentences, output_path, source_language, target_language
            )

        elif format_type == "pdf":
            ExportService.export_to_pdf(
                sentences, output_path, source_language, target_language
            )

        else:
            raise ValueError(f"Unsupported format: {format_type}")

        return output_path
